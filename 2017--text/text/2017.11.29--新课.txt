1.优点
2.
3.自定义构造函数
a)实例化对象的时候可以很方便的进行属性的修改
b)可以方便的实现多个对象的声明


对象的原型
	一般,对象的原型是该对象的__proto__属性指向的一个对象
	__proto__是一个非标准属性 存在兼容性问题
	原型的constructor指向其构造函数

函数 
	在js中只有函数才能划分作用域
	

	函数就是把一段代码进行封装,实现复用

函数的作用

1.可以实现代码的复用
2.可以用来划分作用域
3.可以作为参数进行传递(回调函数)
4.外层函数嵌套内层函数(闭包函数)
5.函数内部调用函数(递归思想)

函数是js 中的一等公民

函数可以划分作用域

作用域链的变量查找原则
当要使用一个变量的时候，首先在当前作用域进行查找,如果有
就拿来用,如果没有，就向上一级作用域进行查找,如果有,就使用
否则就继续向上一级查找,直到全局作用域,如果有就使用,
如果没有就报错



1.函数的this指向
a)构造函数中的this指向实例化出来的对象
b)普通函数中this指向window对象
c)方法 函数中this指向方法函数的调用者
d)闭包函数中 this 指向window对象
 

2.函数的调用方式
a）构造函数的调用方式：	New  xxx()
判断一个是否是构造函数只要看其调用方式即可,有new就是构造函数,没有就不是
	
b）普通函数调用方式 	函数名()

c）方法函数调用方式	对象.方法函数名

d) 闭包函数的调用方式和普通函数的调用方式完全相同
因此闭包函数的this也指向window对象。

e）上下文调用方式 (call/apply)

使用call和apply方法的函数叫做立即执行函数,这样的函数不会受js
事件处理机制的限制,会立即执行,当obj传入null或undefined的时候,this指向
window

函数名.call/apply(obj,"arg1" "arg2" "arg3" "arg4")
在 obj实参之后,传入的所有实参都是调用call/apply方法的函数所要接收
到的实参

在函数中 this指向谁,this就是谁


函数的声明方式
1.函数声明
2.函数字面量
3.构造函数声明


闭包函数 
	
	闭包函数就是外层函数嵌套内层函数，并
在外层函数中返回内层函数的调用

优点：可以避免全局对象的污染,因为在js中,函数是可以用来划分作用域的
外层函数不能访问到内层的变量，而内层函数可以访问到外层函数的变量

缺点：在闭包函数的内层函数中定义的变量
在使用完之后是不会被js的垃圾处理机制清理掉的,就会造成内存性能
上的极大消耗,严重的时候甚至会造成内存泄漏
因此,针对闭包函数的这一缺点,我们应该在变量使用完成之后, 
手动清除一下

js中实现继承
1.构造继承
使用构造函数实现对对象的继承
2.原型继承
就是通过定义一个对象的原型来给对象实现继承
3.实例化继承(混合继承)
把 所有对象的共有属性卸载原型中，把各个对象的私有属性写在
构造函数




isprototype（）
是Object.prototype里面包含的方法返回值是布尔类型
true表示当前对象是指定对象的原型,false表示不是

hasOwnProperty	判断一个属性是否是当前对象自身的属性
返回值为布尔值 



1.字符串转数字
a）Number(srting)
b)parseInt/parseFloat
c)隐式转换
	string*1/string/1/string-0
2.数字转字符串
a)String(number);
b)toString();
c)Number+""'
d)New String(number)


3.其他值类型转布尔值
a)值不为0的数字---->true
b)非空的字符串-----》true
c)null和undefined----》false
d)0和“”-----》false
e)对象----》true

其他类型转换成布尔值的方法：
！！变量

typeof		



Instanceof
作用：是用来判断指定函数是否是当前对象的构造函数的
  如果是，就返回true；如果不是，就返回false


==和===

==运算规则：将操作符两边的操作数先进行数据类型转换，将
数据类型转换成相同的类型后，再进行比较

	=== 运算规则：将操作符两端的操作数直接比较，即比类型 也比值
1.当两个操作数有且只有一个是数字类型的时候，就将另一个也转换成数字类型

2.当两个操作数有且只有一个是布尔类型的时候，就先将布尔类型的数据转换成数字
类型

3.当两个操作数有且只有一个事对象类型的时候，就把 对象类型转换为值类型的数据
优先使用valueof方法进行转换，如果不行，就使用toString方法


所有的字符串，只要不是空字符串，其布尔值都是true

内置对象的方法
字符串：
	1.检索 indexof、match、search
	2.替换 splice
	3.截取 substr  substring slice
	4.切割 split
数组
	1.添加 push、unshift	
	2.删除 pop、shift、splice
	3.截取 slice
	4.合并 concat

拼接字符串：join

getFullYear()年

getMonth()+1月

getDate()日

getDay()周几
	
dom相关属性及方法
Document.querySelector()
Document.querySelectorAll()
1.追加：
a）appendChild（新节点）
b）insertBefore（新节点，当前节点）


工厂函数

	在构造函数调用的时候如果调用不当，没有写new，就会被当做普通函数来
	执行，这样，实例化对象就无法实现，并且还会造成全局window对象的污染
	因此，可以使用工厂模式，在工厂函数内部调用构造函数实例化对象，并
	返回实例化出来的对象：这样用户在调用的时候，写不写new都不会出问题

	工厂函数其实就是在函数体内部给对象绑定属性，并把绑定好属性的对象
	当做返回值，返回给用户，因此在工厂函数中，可以使用任何方式去创建对象
注意：	在创建对象的时候，构造函数实例化的方式比json方式类型更强  因此，在
	某些对象类型要求严格的情况下，要使用构造函数创建对象



传统的后台编程语言中

	java 、c、VB、c#、c++
	都存在一个概念  类 用来实现继承的三大特性：多态、继承、封装
	
	面向过程的思想
	面向函数思想  组件化思想

	缺点：1.会产生过多的全局变量,因此，就有可能造成命名冲突
	2.会造成window对象过于庞大冗余，污染window对象
	3.函数与函数之间没有关系，就会导致使用的时候很混乱
	Function(){
		function(){
		$().
		}
	}
	面向对象
	为了解决面向函数思想中全局对象的污染问题而产生的一种思想，把
	功能函数绑定给指定的对象，并通过原型和构造函数实现属性的继承，
	这就是面向对象思想
	
	缺点：会造成代码复杂度大大提高

	video 视频
	Audio 音频
	h5	新增了语义化标签
	h5 包括 html的增强 h5
	Css的增强  c3
	Dom的增强 一些新增的api接口
	h5的新增标签
	语义化标签
	Div
	Header、footer、label、section、nav、form、

	Form表单元素中所有的按钮在提交的时候都会刷新页面


	Input

	h5存在兼容性问题
	h5shilf 插件,可以解决h5的新增标签的兼容性问题
	Ie6-8 display：block
	Dom的新增api  (接口)
	addClass()
	removeClass()
	toggleClass()
	Classlist() 会获取到指定元素的所有类名
	Classlist.add添加类名
	Classlist.remove  移除类名
	Classlist.toggle  切换类名

	cookie 曲奇
	实现前端缓存后台数据的功能
	存的时间死板，cookie存储数据的时间是有程序员自定义的
	存储量极小   4kb

	localStorage
	sessionStorage
作业：查 cookie、localStorage、sessionStorage之间的联系和区别


	jQuery js的类库
	jq是通过操作dom元素来实现前端页面的样式的设置的
	jq最基本的特性是解决了js中各种浏览器之间的兼容性问题

	Jquery的各种选择器
	类名、标签、id、属性选择器、伪类选择器JQuery的选择器和css3的选择器是相同的


	jquery中的aniamte动画其实是以js为基础实现的缓动动画，本质上是补间动画
	会很耗费性能，不如cs中的过渡动画好 


	核心  链式编程：
















































